use proc_macro::TokenStream;
use quote::quote;
use rust_wren_derive_backend::{
    build_wren_methods, gen_class_props, gen_from_wren_impl, gen_to_wren_impl, strip_prop_attrs, WrenClassArgs,
};
use syn::{
    self,
    parse::{Parse, ParseStream},
    parse_macro_input,
    punctuated::Punctuated,
    Expr, Ident, ItemImpl, ItemStruct, Token,
};

#[proc_macro_attribute]
pub fn wren_class(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr = parse_macro_input!(attr as WrenClassArgs);
    let item = parse_macro_input!(item as ItemStruct);

    impl_wren_class(attr, item)
}

fn impl_wren_class(attr: WrenClassArgs, mut item: ItemStruct) -> TokenStream {
    let struct_ident = item.ident.clone();
    let class_name = if let Some(name) = attr.name {
        // Use explicitly given name in attribute.
        match name {
            Expr::Path(path_expr) if path_expr.path.segments.len() == 1 => {
                path_expr.path.segments.first().unwrap().ident.to_string()
            }
            // TODO: Better error span
            _ => panic!("Wren class attr unexpected name expression type"),
        }
    } else {
        // Use struct name from Rust.
        struct_ident.to_string()
    };

    let from_wren_impl = gen_from_wren_impl(struct_ident.clone());
    let to_wren_impl = gen_to_wren_impl(struct_ident.clone());
    let props_impl = gen_class_props(&item).expect("Failed to generate property accessors");

    strip_prop_attrs(&mut item.fields);

    let gen = quote! {
        #item

        impl rust_wren::class::WrenForeignClass for #struct_ident {
            const NAME: &'static str = #class_name;

            fn register(bindings: &mut rust_wren::ModuleBuilder) {
                // Allocate and finalize are generated by impl and methods macros.
                let foreign_class = rust_wren::foreign::ForeignClass {
                    allocate: <Self>::__wren_allocate,
                    finalize: <Self>::__wren_finalize,
                };
                let class_name = <Self as rust_wren::class::WrenForeignClass>::NAME;
                bindings.add_class_binding(class_name, foreign_class);
                bindings.add_reverse_class_lookup::<Self>();
                Self::__wren_register_methods(bindings);
                Self::__wren_register_properties(bindings);
            }
        }

        #from_wren_impl

        #to_wren_impl

        #props_impl
    };

    gen.into()
}

#[proc_macro_attribute]
pub fn wren_methods(_: TokenStream, item: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(item as ItemImpl);

    build_wren_methods(ast)
        .expect("Failed to generate wren method implementations")
        .into()
}

/// Convenience macro for creating an error that has compile time line and module information.
#[proc_macro]
pub fn foreign_error(args: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(args as Expr);

    let gen = quote! {
        // Wren uses a signed int for its line numbers, so we're matching that to keep the stack frame consistent
        // between foreign and non-foreign stack frames.
        rust_wren::ForeignError::Annotated {
            line: line!() as i32,
            module: file!().to_owned().replace("\\", "/"),
            inner: Box::new(#ast),
        }
    };

    gen.into()
}

/// Generate an implementation for converting a tuple struct to Wren slots.
#[proc_macro]
pub fn generate_tuple_to_wren(args: TokenStream) -> TokenStream {
    let ToWrenSpec { type_idents } = parse_macro_input!(args as ToWrenSpec);

    let var_idents = type_idents
        .iter()
        .map(|ident| Ident::new(&ident.to_string().to_ascii_lowercase(), ident.span()))
        .collect::<Vec<Ident>>();

    let where_idents = type_idents
        .iter()
        .map(|ident| {
            quote! { #ident :ToWren }
        })
        .collect::<Vec<_>>();

    let slots_idents = type_idents
        .iter()
        .zip(var_idents.iter())
        .enumerate()
        .map(|(idx, (ty, var))| {
            let idx = idx as i32;
            quote! {
                #ty::put(#var, ctx, slot + #idx)
            }
        })
        .collect::<Vec<_>>();

    let size_hint = type_idents.len();

    let gen = quote! {
        impl<#(#type_idents),*> ToWren for (#(#type_idents),* ,)
        where
            #(#where_idents),*
        {
            fn put(self, ctx: &mut WrenContext, slot: i32) {
                let (#(#var_idents),* ,) = self;
                #(#slots_idents);*
            }

            fn size_hint(&self) -> usize {
                #size_hint
            }
        }
    };

    gen.into()
}

#[derive(Default)]
struct ToWrenSpec {
    /// Struct type identifiers.
    type_idents: Vec<Ident>,
}

impl Parse for ToWrenSpec {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut spec = ToWrenSpec::default();
        let punctuated = Punctuated::<Expr, Token![,]>::parse_terminated(input)?;

        for expr in punctuated.into_iter() {
            match expr {
                Expr::Path(expr_path) => {
                    if let Some(ident) = expr_path.path.get_ident().cloned() {
                        spec.type_idents.push(ident);
                    } else {
                        return Err(syn::Error::new_spanned(
                            expr_path,
                            "Generate arguments must be identifiers.",
                        ));
                    }
                }
                _ => {
                    return Err(syn::Error::new_spanned(expr, "Generate arguments must be identifiers."));
                }
            }
        }

        Ok(spec)
    }
}
