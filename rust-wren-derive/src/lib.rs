use proc_macro::TokenStream;
use quote::quote;
use rust_wren_derive_backend::{build_wren_methods, WrenClassArgs};
use syn::{self, parse_macro_input, Expr, ItemImpl, ItemStruct};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}

#[proc_macro_attribute]
pub fn wren_class(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr = parse_macro_input!(attr as WrenClassArgs);
    let item = parse_macro_input!(item as ItemStruct);

    impl_wren_class(attr, item)
}

fn impl_wren_class(attr: WrenClassArgs, item: ItemStruct) -> TokenStream {
    let struct_ident = item.ident.clone();
    let class_name = if let Some(name) = attr.name {
        // Use explicitly given name in attribute.
        match name {
            Expr::Path(path_expr) if path_expr.path.segments.len() == 1 => {
                path_expr.path.segments.first().unwrap().ident.to_string()
            }
            _ => panic!("Wren class attr unexpected name expression type"),
        }
    } else {
        // Use struc tname from Rust.
        struct_ident.to_string()
    };

    let gen = quote! {
        #item

        impl rust_wren::WrenForeignClass for #struct_ident {
            const NAME: &'static str = #class_name;

            fn register(bindings: &mut rust_wren::ModuleBuilder) {
                // Allocate and finalize are generated by impl and methods macros.
                let foreign_class = rust_wren::foreign::ForeignClass {
                    allocate: <Self>::__wren_allocate,
                    finalize: <Self>::__wren_finalize,
                };
                let class_name = <Self as rust_wren::WrenForeignClass>::NAME;
                bindings.add_class_binding(class_name, foreign_class);
                Self::__wren_register_methods(bindings);
            }
        }
    };

    gen.into()
}

#[proc_macro_attribute]
pub fn wren_methods(_: TokenStream, item: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(item as ItemImpl);

    build_wren_methods(ast)
        .expect("Failed to generate wren method implementations")
        .into()
}
